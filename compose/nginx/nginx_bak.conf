# 检查当前用户是否能远程登录
# Passwd -s $NGINX_USER
# Shell script chsh -s /sbin/nologin $NGINX_USER
user  username usergroup;
worker_processes  auto; #定义了nginx的工作进程数,以Cpu核数为准
worker_rlimit_nofile 65535;
error_log  logs/error.log; #Nginx错误日志存放路径
pid        logs/nginx.pid; #Nginx服务运行后产生的pid进程号

events {
    use epoll; # 事件驱动模型默认值epoll
    worker_connections  65535;
}


http {
    include       mime.types; #包含/etc/nginx/conf.d/目录下所有以.conf结尾的文件
    default_type  application/octet-stream;
    server_tokens off; # nginx版本
    autoindex off;# 禁止开启目录列表功能
    port_in_redirect off; # 禁止nginx重定向至监听端口
    client_body_timeout 10; # 默认时间为60秒,超过这个时间客户端没有发送数据,nginx返回408 request timeout
    client_head_timeout 10; # 默认时间为60秒,超过这个时间客户端没有发送数据,nginx返回408 request timeout
    # 第一个参数5指客户端连接保持活动的超时时间默认事75,第二个参数65是可选的,指消息头保持活动的有效时间,它可以告诉某些浏览器器关闭连接,因此服务器就不必关闭连接,如果没有这个参数,nginx不会发送keep-alive这个头
    keepalive_timeout 5 65;
    # 指定响应客户端的超时时间,这个超时仅仅限于两个阅读活动之间的时间,如果这个时间后客户端没有任何活动,nginx会关闭连接
    send_timeout 10;#单位为秒
    proxy_hide_header x-powered-By ; #x-powered-By表示网站用什么技术开发的,它会泄露开发语言版本号和框架信息,有安全隐患,需要隐藏
    # HttpLimitReqModule用来限制单位时间内连接数的模块,使用limit_req_zone和limit_req指令配合使用达到限制,一旦并发连接超过指定数量,就会还回503
    # $binary_remote_addr:是限制同一客户端ip
    # zone=name:size,分配一个以name为名的并且大小为size的空间,用来存储访问频次的信息
    # rate=nr/s,如果rate=5r/s表示同一个ip每200毫秒(1000毫秒/5=200毫秒)只允许一个请求通过
    # brust=x,表示设置一个大小为x的缓冲区,超过频次限制的请求先放入缓存区
    # nodelay 不延迟处理
    limit_req_zone $binary_remote_addr zone=one:100k rate=20r/s

    # 打开此nginx的访问日志功能,即可查看日志,日志格式设定
    #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址(如果中间有代理服务器那么显示的就ip就为代理服务器的ip地址)
    #$remote_user：用来记录客户端用户名称(一般为 '-')；
    #$time_local： 用来记录访问时间与时区；
    #$request： 用来记录请求的url与http协议(如果记录的url中包含了敏感信息则需要进行检查,并不记录在日志中)；
    #$status： 用来记录请求状态；成功是200，
    #$body_bytes_sent ：记录发送给客户端文件主体内容大小；
    #$http_referer：用来记录从那个页面链接访问过来的；
    #$http_user_agent：记录客户浏览器的相关信息；
    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                     '$status $body_bytes_sent "$http_referer" '
                     '"$http_user_agent" "$http_x_forwarded_for"';
    access_log logs/access.log main;
    #access_log  "pipe:rollback logs/host.access_log interval=1d baknum=7 maxsize=2G"  main;
    sendfile        on;
    #获取用户真实ip,并且赋值给变量$clientRealIp
    map $http_x_real_client_addr $clientRealIp {
        "" $remote_addr;
        ~^(?P< >[0-9.]+).?.*$firstAddr;
        default $http_x_real_client_addr;
    }
    gzip  on;# nginx开启静态资源压缩,比如nginx返回磁盘的html文件特别大,里面包含了诸多的静态文件,极大提升网站访问

    upstream gunicorn_app {
        hash $clientRealip;
        server 127.0.0.1:8080;
        server 127.0.0.1:8081;
    }


    server {
        listen       ip:port ssl;
        server_name  www.example.com;
        charset utf-8; #网站编码

        # ssl配置
        ssl_certificate 公钥证书orpt.pem地址;
        ssl_certificate_key 私钥证书private.key地址;
        ssl_password_file   私钥证书密码keypass地址
        ssl_ciphers "ECDHE-RSA-AES-256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256"   # 使用安全密码套件
        ssl_prefer_server_ciphers on    # 协商时优先使用服务器指定的加密算法
        ssl_session_cache shared:SSL:1m; # 每1M缓存可以存储4000个会话,有效提升https网站处理ssl并发的能力
        ssl_seesion_timeout 5m; # 设置合适的超时时间
        # 设置在线证书状态协议
        # OCSP(Online Certificate Status Protocol)在线证书状态协议,用来验证网站证书有效性
        # 使用OCSP可以加快https链接的建立,减少客户端带宽使用,OCSP客服了证书注销列表(CRL)的主要缺点,必须经过经常在客户端浏览器下载以确保更新,浏览器只需要像证书提供的OSCP服务器发送一个请求就可以验证证书状态而不需要下载整个CRL
        # 如果ssl_certificate中没有包含中级证书(证书链不完整)我们就必须设置ssl_trusted_certificate,里面包含PEM格式的CA根证书和中级证书(通过ssl_trusted_certtificate)设置完整证书链
        ssl_stapling on;
        ssl_stapling_verify on;
        ssl_protocols TLSv1.2 TLSv1.3 #nginx1.13.0版本开始支持TLSv1.3,#如果不配置ssl_protocols,默认使用TLSV1，TLSV1.1,TLSV1.2根据,安全要求TLS协议,ngin需要openssl版本>=1.01来支持TLSv1.2


        # 响应头配置
        add_header X-XSS-Protection "1; mode=block";    #提供xss防护功能,必须设置
        add_header Content-Security-Policy "default-src 'self' data: *.xxx.com  'unsafe-inline' 'unsafe-eval' mediastream: ";
        add_header X-Content-Type-Options "nosniff";#提供禁用浏览器的类型猜测功能,必须设置
        add_header X-Frame-Options SAMEORIGIN; #提供点击劫持防护功能必须设定
        add_header Strict-Transport-Security "max-age=63072000; includeSubdomains; preload";# 提供请求强制走https协议功能,必须设置
        add_header Pragma no-cache; #页面缓存控制响应头
        add_header Expire 0;
        add_header Cache-Control "no-cache,no-store,must-revalidate";
        add_header Referrer-Policy "no-referner";
        # 当一个源站点将用户定向到另一个站点时，将发送一个确定用户来源的url的推荐人，根据您网站的具体用途，就可能会给您的用户带来隐私问题。Referring策略允许组织定义哪些站点应该看到来自您站点的推荐，这有助于保护用户隐私。如果在url参数如个人信息，用户名和密码或持久会话中使用敏感数据,则refer标头可能会在另一个为服务器的日志中公开平台数据，最终根据您的应用程序设计,不使用正确配置的refer策略可能会导致会话劫持凭据收集或者第三方日语中的敏感数据泄露。
        add_header X-Download-Options noopen;
        add_header X-Permitted-Cross-Domain-Policies none;



        # 请求头和请求体设置
        large_client_header_buffers 4 8k; # 参数含义是申请4个8K的请求头缓冲区
        client_header_buffer_size 1k; # nginx默认会用client_header_buffer_size来读取header
        client_body_buffer_size 16k;  # 缓冲客户端请求的最大字节
        client_max_body_size 16k; #客户端请求最大单文件字节数
        client_max_body_size 5m; #客户端请求的最大单文件字节数
        #备注:没有以上所定义的缓冲就是大小是建议值,在报告请求过程中,报request url too large (414)或者bad request(400)错误,则需增加缓冲区大小,产品如果有特殊要求,可以根据自身的需求进行.相应的调整

        # 代理设置
        proxy_connect_timeout 180;
        proxy_read_timeout 180;
        proxy_send_timeout 180;

        # 静态文件设置
        location /dbcompass/static {
            add_header X-XSS-Protection "1; mode=block";    #提供xss防护功能,必须设置
            add_header Content-Security-Policy "default-src 'self'"; # 提供对加载资源的安全控制功能
            add_header X-Content-Type-Options "nosniff";#提供禁用浏览器的类型猜测功能,必须设置
            add_header X-Frame-Options SAMEORIGIN; #提供点击劫持防护功能必须设定
            add_header Pragma no-cache; #页面缓存控制响应头
            add_header Expire 0;
            add_header Cache-Control "no-cache,no-store,must-revalidate";
            add_header Strict-Transport-Security "max-age=31536000; includeSubdomains";# 提供请求强制走https协议功能,必须设置
            alias 静态文件地址;
        }


        location / {
            # 代理设置
            proxy_pass   http://gunicorn_app;
            proxy_set_header Host $host;
            #X-forward-for和 remote address标头有助于识别和分离用户代理的原始客户端IP地址和代理IP地址,这两种类型地址是相同的,其中一种应该始终存在。将客户端的真实IP地址作为x-real-ip的值传递给后端服务器，以便后端服务器可以获取客户端的真实ip地址。The panda x rio IP dollar remote。Address
            proxy_set_header X-Real-IP $remote_addr;
            #将客户端的真实IP地址添加到x-forward-for头部中,以便后端服务器可以获取客户端的IP地址和代理服务器的IP地址。
            proxy_set_header X-Forwarded-For $proxy_add_x_forward_for;
            #将客户端的真实IP作为X-Gunicorn-IP的值传递给后端服务器,以便后端服务器可以获取客户端的真实IP地址。这个指令是针对使用Gunicorn作为应用服务器的情况下的设置
            proxy_set_header X-Gunicorn-IP $http_x_real_client_addr;

            #real_ip_recursive,这是一个nginx配置命令,用于指定是否递归地将X-Forwarded-For投中所有IP地址替换为客户端的真实IP地址。如果设置为on, nginx将递归递查找 X-Forwarded-For头中所有的IP地址,并将最后一个IP地址替换为客户端的真实IP地址。
            real_ip_recursive on;

            limit_except GET POST HEAD {
                deny all; # HTTP请求方法在全目录'/'目录下除了get post head返回403除
            }


            index  index.html index.htm;
        }

        location ~*\.(gif|png|bmp|jpe?g)$ {
            expires 7d;
            add_header Pragma public;
            add_header Cache-Control "public,must-revalidate,proxy-revalidate";
            valid_referers none blocked ~.google.~.baidu.server_names ~($host);
            if ($invalid_referer) {
                rewrite(.*) /static/images/hotlink-denied.jpg redirect;
                                   }
            }

        location = /favicon.ico {
            log_not_found off;
            access_log off;
        }


        # nginx发生服务端出错时，例如nginx在找不到网页时会报404错误，错误页面上经常会附带当前服务器版本号还可能会泄露其他服务器端信息,黑客可以通过版本I号,查询当前nginx服务器的默认配置信息。以及版本安全漏洞，如果出错页面带有版本号等敏感信息，这必须对出错信息进行定制。
        error_page  404              /404.html;
        location = /40x.html {
            root   web/error;
        }

        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   web/error;
        }
}

    server {
        listen       6060;
        server_name  www.example.com;

        location / {
            proxy_pass   http://127.0.0.1:8888;
        }


        error_page  404              /404.html;
        location = /40x.html {
            root   web/error;
        }

        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   web/error;
        }
}


}

